# 序言

基本数据类型一般来说分配在栈区，编译器存在一个逃逸分析

引用数据类型一般分配到堆区

## init 函数

每个源文件都可以有一个 init 函数，执行顺序，先执行变量定义的函数，最后执行main函数

先执行引入文件的 init 函数在执行当前文件的 init 函数

## 错误处理机制

错误处理方式：defer、panic、recover

可以抛出一个 panic 的异常，然后在 defer 中通过 recover 捕获这个异常，然后正常处理

~~~go
defer fun (){
    err := recover()	//recover()内置函数，可以捕获异常
    if err != nil{		//说明捕获到错误
        fmt.Println("err=",err)
        //错误处理
    }
}()
~~~

### 自定义错误

~~~go
//使用 errors.New 和 panic 内置函数
errors.New("错误说明") //返回一个error类型的值，表示一个错误
panic //内置函数
~~~

## goroutine

### 协程和主线程

**go协程的特点**

1. 有独立的栈空间
2. 共享程序堆空间
3. 调度由用户控制
4. 协程是轻量级的线程

### MPG模式

- M：操作系统的主线程（物理线程）
- P：协程执行需要的上下文
- G：协程

### 设置运行 cpu 数目

> 1.8之前需要设置
>
> 1.8之后不需要设置，默认运行在多核上

~~~Go
func main(){
    cpuNum := runtime.NumCPU()
    fmt.Println("cpuNum",cpuNum)
    
    runtime.GOMAXPROCS(cpuNum - 1)
    fmt.Println("ok")
}
~~~

管道



## 网络编程

**端口分类**

- 0：保留端口号

- 1-1024：固定端口

  > 22：SSH远程登录协议
  > 23：telnet使用
  > 24：ftp使用
  > 25：smtp服务使用
  > 80：iis使用
  > 7：echo使用

go run  : 编译并运行

go build ：编译程序，并生成一个可运行的exe文件

# 正文

**变量声明注意事项**

变量使用` := `声明只能在函数体内使用

多变量不同类型声明方式

~~~go
var(
	k int
    t 
)
~~~

**函数的多返回值**

返回值是匿名的，返回值跟在 return 后面

返回值有名称的，在函数最后赋值，只写 return 就好

**导包**

- `.`：表示引入这个包的所有变量和方法，在使用的时候可以直接使用这个包里面的方法和变量，类似将这个包里面的代码插入到当前包
- `_`：只调用这个包的 init 方法
- 别名：在前面直接加上别名，默认为是包名

**切片细节**

对切片再进行切片，两个切片会指向同一个内存地址，

使用copy操作切片，会创建新的切片，

**append操作原理**

先创建一个新的数组，将旧的数组内容 copy 过去，然后将新添加的内容追加过去，再将旧的数组删除，最后将指针指向新的数组

## 反射reflect

Valueof 和 Typeof

