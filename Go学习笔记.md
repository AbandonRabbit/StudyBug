# 序言

内存管理主要包含两个动作：分配和释放。逃逸分析就是服务于内存分配的，而内存的释放有GC负责

## 逃逸分析

> 基本数据类型一般来说分配在栈区，编译器存在一个逃逸分析
>
> 引用数据类型一般分配到堆区

用来标识变量内存应该被分配到栈区还是堆区，分配时遵守一下两种规则

1. 指向栈上对象的指针不能被存储到堆中 —— 堆中的变量通常生命周期更长
2. 指向栈上对象的指针不能超过该栈对象的生命周期

## init 函数

每个源文件都可以有一个 init 函数，执行顺序，先执行变量定义的函数，最后执行main函数

先执行引入文件的 init 函数在执行当前文件的 init 函数

## 指针

函数传递参数时，大对象是否要传递指针，要进行分析，因为在内存分配机制中，这个大对象的内存会被分配到堆上，增加系统开销

## 类型转换

~~~go
目标类型(V)
~~~

注意：

1. 数据类型可以大转小，也可以小转大
2. 被转换的是变量存储的数据(值)，变量本身的数据类型并没有发生变化
3. 如果将高精度转换为低精度，编译时不会报错，只是转换的结果是按溢出处理
4. 数据类型转换必须显示转换

### 基本数据类型转 string

~~~go
//方式一
fmt.Sprintf(format_String,interface{})  //返回string

//方式二
使用strconv包的函数
~~~



## 错误处理机制

错误处理方式：defer、panic、recover

可以抛出一个 panic 的异常，然后在 defer 中通过 recover 捕获这个异常，然后正常处理

~~~go
defer fun (){
    err := recover()	//recover()内置函数，可以捕获异常
    if err != nil{		//说明捕获到错误
        fmt.Println("err=",err)
        //错误处理
    }
}()
~~~

### 自定义错误

~~~go
//使用 errors.New 和 panic 内置函数
errors.New("错误说明") //返回一个error类型的值，表示一个错误
panic //内置函数
~~~

## goroutine

### 协程和主线程

**go协程的特点**

1. 有独立的栈空间
2. 共享程序堆空间
3. 调度由用户控制
4. 协程是轻量级的线程

### MPG模式

- M：操作系统的主线程（物理线程）
- P：协程执行需要的上下文
- G：协程

### 设置运行 cpu 数目

> 1.8之前需要设置
>
> 1.8之后不需要设置，默认运行在多核上

~~~Go
func main(){
    cpuNum := runtime.NumCPU()
    fmt.Println("cpuNum",cpuNum)
    
    runtime.GOMAXPROCS(cpuNum - 1)
    fmt.Println("ok")
}
~~~

### 调度器的设计策略

1. 复用线程

   1. work stealing 机制：将线程a上等待的协程换到空闲的线程上面执行
   2. hand off 机制：当线程a有多个协程，并当前运行的协程被阻塞或等待，则新建一个线程，将线程a上面的协程放到新建的线程上，然后将线程a睡眠，等到阻塞的协程运行完毕，根据情况将这个协程销毁或放在其他队列，并将所在的线程销毁

2. 利用并行

   通过 GOMAXPROCS 限制 P 的个数，

3. 抢占

   每个 G 最多可以使用 CPU 10ms 如果没执行完毕，则被新的 G 抢占

4. 全局 G 队列

   对 work stealing 机制的补充，当所有 P 的本地队列都为空时，从全局队列拿取（当 G 被阻塞或睡眠时放入全局队列）

## 管道channel

管道一定不能被读取者close()

管道不能只有写或只有读，必须两者都有，可以频率不一致，否则会触发deadlock

一个数据结构 - 队列
先进先出的
线程安全，多goroutine访问时，不需要加锁，不会发生资源竞争问题
有类型，一个string的channel只能放string类型数据

~~~go
//定义/声明
//可以声明为只读或只写，在 chan 前面或后面加上 <-
var 变量名 chan 数据类型

//初始化
变量名 = make(chan 数据类型，长度)

//向管道写入数据
变量名<- value

//取值
value<- 变量名

//注意
空接口类型，在读取的时候要进行类型断言
~~~

说明：

1. channel 是引用类型
2. channel必须初始化才能写入数据，即make后才能使用
3. 管道是有类型的，intChan只能写入整数 int
4. 数据放满就不能再放，数据取完就不能再取

### 遍历和关闭

#### 关闭

当channel关闭后，不能再写入数据，只能读数据

~~~go
//使用内置幻术close可以关闭channel
close(channelName)
~~~

#### 遍历

使用for-range遍历

1. 再遍历时，如果channel没有关闭，会出现deadlock的错误
2. 再遍历时，如果channel已经关闭，则会正常遍历

~~~go
for v:=range channel{
    //循环体
}
~~~



## 网络编程

**端口分类**

- 0：保留端口号

- 1-1024：固定端口

  > 22：SSH远程登录协议
  > 23：telnet使用
  > 24：ftp使用
  > 25：smtp服务使用
  > 80：iis使用
  > 7：echo使用

go run  : 编译并运行

go build ：编译程序，并生成一个可运行的exe文件

**buindin 内置函数**



## 单元测试



# 正文

**变量声明注意事项**

变量使用` := `声明只能在函数体内使用

多变量不同类型声明方式

~~~go
var(
	k int
    t 
)
~~~

**函数的多返回值**

返回值是匿名的，返回值跟在 return 后面

返回值有名称的，在函数最后赋值，只写 return 就好

**导包**

- `.`：表示引入这个包的所有变量和方法，在使用的时候可以直接使用这个包里面的方法和变量，类似将这个包里面的代码插入到当前包
- `_`：只调用这个包的 init 方法
- 别名：在前面直接加上别名，默认为是包名

**切片细节**

对切片再进行切片，两个切片会指向同一个内存地址，

使用copy操作切片，会创建新的切片，

**append操作原理**

先创建一个新的数组，将旧的数组内容 copy 过去，然后将新添加的内容追加过去，再将旧的数组删除，最后将指针指向新的数组

## 反射reflect

Valueof 和 Typeof

