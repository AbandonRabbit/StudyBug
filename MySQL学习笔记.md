# 用户数据管理

## 管理用户

~~~sql
/*查询用户*/
SELECT * FROM user

/*创建用户*/
CREATE USER '用户名'@ '主机名' IDENTIFUED BY '密码'

/*修改用户密码*/
ALTER USER '用户名'@ '主机名' IDENTIFUED WITH mysql_native_password BY '新密码'

/*删除用户*/
DROPUSER '用户名'@ '主机名'
~~~

主机名可以用%通配符，表示任意

## 权限控制

~~~sql
/*查询权限*/
SHOW GRANTS FOR '用户名'@ '主机名'

/*授予权限*/
GRANT 权限列表 ON 数据库名.表名 TO '用户名'@ '主机名'

/*撤销权限*/
REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@ '主机名'
~~~

> 多个权限之间，可以使用逗号分隔
>
> 授权时，数据库名和表名可以使用 * 进行统配，表示所有

# 函数

## 字符串函数

| 函数                     | 功能                                                       |
| ------------------------ | ---------------------------------------------------------- |
| CONCAT(S1,S2,...Sn)      | 字符串拼接，将S1，S2，... Sn拼接成一个字符串               |
| LOWER(str)               | 将字符串str全部转为小写                                    |
| UPPER(str)               | 将字符串str全部转为大写                                    |
| LPAD(str,n,pad)          | 左填充，用字符串pad对str的左边进行填充，达到n个字符 串长度 |
| RPAD(str,n,pad)          | 右填充，用字符串pad对str的右边进行填充，达到n个字符 串长度 |
| TRIM(str)                | 去掉字符串头部和尾部的空格                                 |
| SUBSTRING(str,start,len) | 返回从字符串str从start位置起的len个长度的字符串            |

## 数值函数

| 函数       | 功能                               |
| ---------- | ---------------------------------- |
| CEIL(x)    | 向上取整                           |
| FLOOR(x)   | 向下取整                           |
| MOD(x,y)   | 返回x/y的模                        |
| RAND()     | 返回0~1内的随机数                  |
| ROUND(x,y) | 求参数x的四舍五入的值，保留y位小数 |

## 日期函数

| 函数                               | 功能                                             |
| ---------------------------------- | ------------------------------------------------ |
| CURDATE()                          | 返回当前日期                                     |
| CURTIME()                          | 返回当前时间                                     |
| NOW()                              | 返回当前日期和时间                               |
| YEAR(date)                         | 获取指定date的年份                               |
| MONTH(date)                        | 获取指定date的月份                               |
| DAY(date)                          | 获取指定date的日期                               |
| DATE_ADD(date, INTERVAL expr type) | 返回一个日期/时间值加上一个时间间隔expr后的 时间 |
| DATEDIFF(date1,date2)              | 返回起始时间date1 和 结束时间date2之间的天数     |

## 流程控制函数

| 函数                                                         | 功能                                                       |
| ------------------------------------------------------------ | ---------------------------------------------------------- |
| IF(value,t,f)                                                | 如果value为true，返回 t ，否则返回 f                       |
| IFNULL(v1,v2)                                                | 如果 v1 不为空，返回 v1，否则返回 v2                       |
| CASE WHEN [ val1 ] THEN [res1] ... ELSE [ default ] END      | 如果val1为true，返回res1，... 否 则返回default默认值       |
| CASE [ expr ] WHEN [ val1 ] THEN [res1] ... ELSE [ default ] END | 如果expr的值等于val1，返回 res1，... 否则返回default默认值 |

# 存储引擎

## MySQL的体系结构

- 第一层——连接层：接受客户端的链接，完成链接处理，认证授权，安全方案，检查最大链接数
- 第二层——服务层：SQL结构，解析器，查询优化器，缓存
- 第三层——存储引擎层：数据存储和提取的方式，索引在这一层实现
- 第四层——存储层：数据库的相关数据

## 存储引擎简介

存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式 。存储引擎是基于表的，而不是 基于库的，所以存储引擎也可被称为表类型。

~~~mysql
/*查询建表语句*/
show create table 表名;

/*建表时指定存储引擎*/
CREATE TABLE 表名(
    字段1 字段1类型 [ COMMENT 字段1注释 ] ,
) ENGINE = 引擎名 [ COMMENT 表注释 ] ;

/*查询当前数据库支持的存储引擎*/
show engines;
~~~

### InnoDB 存储引擎

在 MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎。

#### 特点 

- DML操作遵循ACID模型，支持事务；
-  行级锁，提高并发访问性能； 
- 支持外键FOREIGN KEY约束，保证数据的完整性和正确性；

#### 文件

xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结 构（frm-早期的 、sdi-新版的）、数据和索引。

#### 逻辑存储结构

1. 表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以 包含多个Segment段。 
2. 段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管 理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。 
3. 区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为 16K， 即一个区中一共有64个连续的页。 
4. 页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默 认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。 
5. 行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时 所指定的字段以外，还包含两个隐藏字段

### MyISAM 存储引擎

是MySQL早期的默认存储引擎

#### 特点

- 不支持事务，不支持外键
- 支持表锁，不支持行锁
- 访问速度快

#### 文件

- xxx.sdi：存储表结构信息
- xxx.MYD: 存储数据
- xxx.MYI: 存储索引

### Memory 存储引擎

Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为 临时表或缓存使用。

#### 特点 

1. 内存存放
2. hash索引（默认）

#### 文件

- xxx.sdi：存储表结构信息

### 区别及特点



## 存储引擎选择

# 索引

## 分类

| 分类     | 含义                                                  | 特点                      | 关键字   |
| -------- | ----------------------------------------------------- | ------------------------- | -------- |
| 主键索引 | 针对于表中主键创建的索引                              | 默认自动创建, 只能 有一个 | PRIMARY  |
| 唯一索引 | 避免同一个表中某数据列中的值重复                      | 可以有多个                | UNIQUE   |
| 常规索引 | 快速定位特定数据                                      | 可以有多个                |          |
| 全文索引 | 全文索引查找的是文本中的关键词，而不是比 较索引中的值 | 可以有多个                | FULLTEXT |

**InnoDB中的索引形式**

| 分类     | 含义                                                        | 特点                 |
| -------- | ----------------------------------------------------------- | -------------------- |
| 聚集索引 | 将数据存储与索引放到了一块，索引结构的叶子 节点保存了行数据 | 必须有,而且只 有一个 |
| 二级索引 | 将数据与索引分开存储，索引结构的叶子节点关 联的是对应的主键 | 可以存在多个         |

聚集索引选取规则

> 1. 主键
> 2. 使用第一个 UNIQUE 作为聚集索引
> 3. 自动生成一个rowid作为隐藏的聚集索引

**回表查询：**先走二级索引找到主键值，在去聚集索引中拿到这一行的行数据

## sql性能分析

### sql执行频率

~~~sql
/*服务器状态信息*/
-- session 是查看当前会话 ; 
-- global 是查询全局数据 ;
show [session|global] status

/*查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次*/
SHOW GLOBAL STATUS LIKE 'Com_______';
~~~

### 慢查询日志

*慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有 SQL语句的日志*

~~~sql
/*慢查询日志默认没有开启，需要在配置文件（/etc/my.cnf）中配置*/
使用vim添加配置信息
# 开启MySQL慢日志查询开关
slow_query_log=1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time=2
~~~

### profile详情

先使用 `SELECT @@have_profiling;` 查看是否支持 profile 功能

开启 profiling ：`SET profiling = 1;` （可以指定在 session/global级别开启）

~~~sql
-- 查看每一条SQL的耗时基本情况
show profiles;

-- 查看指定query_id的SQL语句各个阶段的耗时情况
show profile for query query_id;

-- 查看指定query_id的SQL语句CPU的使用情况
show profile cpu for query query_id;
~~~

### explain执行计划

EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行 过程中表如何连接和连接的顺序

~~~sql
-- 直接在select语句之前加上关键字 explain / desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;
~~~

**Explain 执行计划中各个字段的含义:**

|              |                                                              |
| ------------ | ------------------------------------------------------------ |
| id           | select查询的序列号，表示查询中执行select子句或者是操作表的顺序 (id相同，执行顺序从上到下；id不同，值越大，越先执行)。 |
| select_type  | 表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接 或者子查询）、PRIMARY（主查询，即外层的查询）、 UNION（UNION 中的第二个或者后面的查询语句）、 SUBQUERY（SELECT/WHERE之后包含了子查询）等 |
| type         | 表示连接类型，性能由好到差的连接类型为NULL、system、const、 eq_ref、ref、range、 index、all 。 |
| possible_key | 显示可能应用在这张表上的索引，一个或多个。                   |
| key          | 实际使用的索引，如果为NULL，则没有使用索引。                 |
| key_len      | 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长 度，在不损失精确性的前提下， 长度越短越好 。 |
| rows         | MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值， 可能并不总是准确的。 |
| filtered     | 表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。 |

## 索引使用

### 最左前缀法则

如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的最左前缀法则指的是，查询时，最左变的列，必须存在，否则索引全部失效。 而且中间不能跳过某一列，否则该列后面的字段索引将失效。（与顺序无关）

### 索引失效情况

范围查询中(>,<)，范围查询右侧的列索引失效。在业务允许的情况下，尽可能的使用类似于 >= 或 <= 这类的范围查询，而避免使用 > 或 <。

在索引列上进行运算操作， 索引将失效。

字符类型数据，不加字符串会导致索引失效

在模糊匹配中，尾部模糊匹配，索引不会失效。头部模糊匹配，索引失效。

当or连接的条件，其中一侧没有索引，索引失效，左右两侧字段都有索引时，索引才会生效。

数据分布，如果MySQL评估使用索引比全表更慢，则不使用索引。

### SQL提示

- use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进 行评估）
- ignore index ： 忽略指定的索引。
- force index ： 强制使用索引。

~~~sql
select * from 表名 sql提示(索引名) where 条件;
~~~

### 覆盖索引

尽量使用覆盖索引（覆盖索引是指 查询使用了索引，并 且需要返回的列，在该索引中已经全部能够找到）

### 前缀索引

当字段类型为字符串，有时候需要索引很长的字符串，者会让索引变得很大，此时可以将字符串的一部分前缀建立索引，可以节约空间

~~~sql
create index idx_xxxx on table_name(column(n)) ;
~~~

**前缀长度**

以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值， 索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。前缀索引主要时解决长字符串数据查询产生了大量的磁盘 IO 情况

~~~sql
-- 不设置索引时的索引选择性
select count(distinct email) / count(*) from tb_user ;
-- 前5个字符的索引选择性
select count(distinct substring(email,1,5)) / count(*) from tb_user ;
~~~

##  索引设计原则

1. 在数据量大，且查询比较频繁的表建立索引
2. 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。
3. 选择区分度高的列，建立唯一索引，区分度越高，索引的效率越高。
4. 字符串较长的列建立前缀索引
5. 尽量采用联合索引，避免回表，提高查询效率
6. 控制索引的数据量，索引越多，维护索引结构的代价就越大
7. 在创建表的时候尽量使用 NOT NULL 约束，方便优化器更好判断索引查询效率

